<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>深入研究敘事網絡：從「詞頻統計」到「結構化行動邏輯」 | Lyuxi Liu</title>
<meta name="keywords" content="Digital Humanities, Computational Social Science, NLP, Narrative Networks, Python">
<meta name="description" content="本文深入探討敘事網絡（Narrative Network）分析範式，介紹從詞袋模型到結構化事件三元組的轉變，詳解語義角色標注（SRL）、實體聚合、網絡骨幹提取等核心技術，並提供 Python 代碼示例與實證應用分析。">
<meta name="author" content="Lyuxi Liu">
<link rel="canonical" href="https://llspublic.github.io/posts/srl/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css" integrity="sha256-NDzEgLn/yPBMy&#43;XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://llspublic.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://llspublic.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://llspublic.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://llspublic.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://llspublic.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://llspublic.github.io/posts/srl/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script><meta property="og:url" content="https://llspublic.github.io/posts/srl/">
  <meta property="og:site_name" content="Lyuxi Liu">
  <meta property="og:title" content="深入研究敘事網絡：從「詞頻統計」到「結構化行動邏輯」">
  <meta property="og:description" content="本文深入探討敘事網絡（Narrative Network）分析範式，介紹從詞袋模型到結構化事件三元組的轉變，詳解語義角色標注（SRL）、實體聚合、網絡骨幹提取等核心技術，並提供 Python 代碼示例與實證應用分析。">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2026-01-04T00:00:00+00:00">
    <meta property="article:modified_time" content="2026-01-04T00:00:00+00:00">
    <meta property="article:tag" content="Digital Humanities">
    <meta property="article:tag" content="Computational Social Science">
    <meta property="article:tag" content="NLP">
    <meta property="article:tag" content="Narrative Networks">
    <meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入研究敘事網絡：從「詞頻統計」到「結構化行動邏輯」">
<meta name="twitter:description" content="本文深入探討敘事網絡（Narrative Network）分析範式，介紹從詞袋模型到結構化事件三元組的轉變，詳解語義角色標注（SRL）、實體聚合、網絡骨幹提取等核心技術，並提供 Python 代碼示例與實證應用分析。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://llspublic.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "深入研究敘事網絡：從「詞頻統計」到「結構化行動邏輯」",
      "item": "https://llspublic.github.io/posts/srl/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "深入研究敘事網絡：從「詞頻統計」到「結構化行動邏輯」",
  "name": "深入研究敘事網絡：從「詞頻統計」到「結構化行動邏輯」",
  "description": "本文深入探討敘事網絡（Narrative Network）分析範式，介紹從詞袋模型到結構化事件三元組的轉變，詳解語義角色標注（SRL）、實體聚合、網絡骨幹提取等核心技術，並提供 Python 代碼示例與實證應用分析。",
  "keywords": [
    "Digital Humanities", "Computational Social Science", "NLP", "Narrative Networks", "Python"
  ],
  "articleBody": " 導言：在社會科學研究中，面對海量文本數據，我們常使用詞雲（Word Cloud）或主題模型（LDA）來提取熱點話題。然而，這些方法僅告訴我們人們在「討論什麼」（What），卻難以揭示「誰對誰做了什麼」（Who did what to whom）這一社會互動的核心邏輯。\n敘事不僅僅是高頻詞的線性排列，更是通過事件將行動者與受體連接起來、建構社會現實的過程。本文將介紹一種新的分析範式——敘事網絡（Narrative Network），並詳細拆解其背後的技術實現路徑。\n為什麼我們需要敘事網絡？ 傳統的詞袋模型將文本表示為無序詞彙的集合，使我們無法重構句子中角色與行動間的確切關係。詞頻或主題分佈固然能提供語料概覽，但 「關鍵詞/主題 ≠ 完整敘事」。例如，LDA 主題模型會將文本歸納為若干主題，但這些主題僅僅是詞的概率分佈，缺乏對敘事結構（如因果、角色互動）的顯式描述。\n敘事網絡（Narrative Network） 提供了一種新的分析範式：將文本視為 事件序列 而非靜態詞集，強調行動者、行動和受事者之間的 結構化互動。換言之，敘事網絡關注 「誰」（施事者） 、 「對誰」（受事者） 、 「做了什麼」（動作），從而捕捉文本中的因果脈絡和責任歸屬。這讓這種範式轉變讓我們得以超越話題探討層面，深入研究語篇如何塑造社會認知與權力結構。\n範式對比：共詞網絡 vs. 敘事網絡 分析維度 共詞網絡 (Co-word Network) 敘事網絡 (Narrative Network) 基本單元 詞彙 A – 詞彙 B（共現關係） 施事者 – 動作 – 受事者（事件三元組） 連接依據 統計關聯（詞頻/共現） 語義互動（角色關係） 網絡類型 無向圖（Undirected） 有向圖（Directed） 可解釋性 話題相關度（討論內容） 行動邏輯（誰對誰做了什麼） 敘事網絡通過保留事件結構，大幅增強了對社會現實構建過程的解釋力。例如，Sudhahar 等人使用新聞報導的主謂賓關係構建網絡，發現美國大選語料中自發形成了支持與反對的兩大陣營。總體而言，相較於傳統詞彙共現分析，敘事網絡能更好地揭示文本背後的權力關係和因果鏈條，是政治傳播、輿情分析等領域強有力的工具。\n第一部分：理論視角——從話題挖掘到敘事解析 文本分析正經歷從「識別顯性話題」向「解析隱含敘事」的範式轉變。傳統方法著重於 顯性內容 （如高頻詞、主題），而敘事解析則關注 隱含結構 （如角色互動、事件邏輯）。這種轉變背後有幾點理論動因：\n人類是「講故事的動物」 ：敘事被視為人類理解和組織現實的基本方式。線上的敘事動態（如話題涌現、競爭、消亡）會對現實社會產生深遠影響。因此，理解網絡輿論中的敘事結構有助於解讀輿情走向與輿論影響。 克服詞袋模型的局限 ：傳統文本表示忽略了語序與句法，導致我們無法區分「狗咬人」與「人咬狗」這樣意義迥異的敘事。相反，敘事分析強調謂詞及其論元角色，精確捕捉「誰做了什麼」的關係。 解釋社會互動 ：敘事網絡將文本轉化為角色-事件圖譜，使研究者得以從全局角度審視互動模式。例如，可透過網絡中心度辨識輿論場中的核心行動者，或通過子群發現特定議題的敘事共同體。 Robert Allen 等人形象地指出，將劇情的時間流程轉化為「二維網絡圖」，可使結構一目了然。總之，應用網絡方法於敘事分析，能讓我們在宏觀上捕捉文本敘事的 對稱性 與 結構特徵，並量化分析角色間的權力互動。\n第二部分：核心技術——語義角色標注 (SRL) 語義角色標注 （Semantic Role Labeling, SRL） 是構建敘事網絡的基石。SRL 的任務是解析句子中謂詞（通常為動詞）及其相關的參與者（論元）角色，即識別「誰在何時何地對誰做了什麼」。這一過程可以視為自動為句子加註劇本角色表：\n謂詞（Predicate） ：通常為句子的主要動詞，表示一個動作或事件。 論元（Arguments） ：與該動作相關的參與者及要素，每個論元扮演特定的語義角色（Semantic Role）。 PropBank 標註體系示例 ARG0 ：施事者（Agent），動作的發起者，對應原型施動者。例如在句子「政府推出了新政策」中， 政府 是 ARG0。 ARG1 ：受事者（Patient），動作的承受者或作用對象。上述例子中， 新政策 是 ARG1。 ARGM ：附加參數（Modifier），包括時間（TMP）、地點（LOC）、方式（MNR）等修飾資訊。 透過 SRL，非結構化的自然語言被轉換為結構化的事件描述。例如句子 “The CDC confirms the first coronavirus case.” 經過 SRL 解析後，可得到如下結構：\n[ARG0: The CDC] [V: confirms] [ARG1: the first coronavirus case]\nSRL 工具與模型 早期的 SRL 系統如 SENNA 就已能自動標注簡單句子的語義角色。近年來，由於預訓練語言模型（如 BERT）的出現，SRL 準確率有了大幅提升。例如 AllenNLP 平台提供了開箱即用的 SRL 模型——一個基於 BERT 的語義角色標注器。我們可以利用該模型快速對文本進行語義解析，無需從零開始訓練：\nfrom allennlp.predictors import Predictor # 加載預訓練的 BERT-SRL 模型（本地路徑或 URL） predictor = Predictor.from_path(\"[https://storage.googleapis.com/allennlp-public-models/bert-base-srl-2020.11.19.tar.gz](https://storage.googleapis.com/allennlp-public-models/bert-base-srl-2020.11.19.tar.gz)\") # 輸入待解析句子 sentence = \"The CDC confirms the first coronavirus case.\" result = predictor.predict(sentence=sentence) # 輸出語義角色標注結果 for verb in result['verbs']: print(verb['description']) # 預期輸出: [ARG0: The CDC] [V: confirms] [ARG1: the first coronavirus case] . ## 第三部分：敘事聚合——從微觀事件到宏觀網絡 經 SRL 解析後，我們將獲得海量 **微觀的敘事碎片** （事件三元組）。但這些原始三元組往往非常稀疏且充斥噪音——畢竟自然語言的表達千變萬化。為了從中抽取穩健的 **集體敘事** ，需要對碎片進行聚合和歸一化處理，使 **相似的角色** 和 **同義的動作** 歸併為統一的節點或關係。 ### 1. 動詞標準化（Verb Normalization） 將語料中意義相近但表達不同的動詞歸並到統一的語義框架下。例如將 “支持”（support）、 “背書”（endorse）、 “力挺”（back）等動詞都映射為「支持類」的通用動作。為實現這一點，可以利用 **VerbAtlas** 等大型詞彙資源。VerbAtlas 手工構建了動詞同義詞與框架的對應關係，將 5,649 個具體動詞歸納為 466 個通用謂詞框架。 ### 2. 論元聚類（Argument Clustering） 解決不同表述指代同一實體的問題。比如語料中出現的 “美利堅合眾國” 、 “美國” 、 “USA” 顯然是同一實體，但計算機視角下它們是不同的字符串。我們可以利用 **語義嵌入+聚類** 的方法來自動合併這些別名實體。實踐中，常使用 **Sentence-BERT** 將每個論元短語向量化，再採用 **凝聚層次聚類** （Hierarchical Clustering）根據語義距離將相似實體歸為一類。 ```python from sentence_transformers import SentenceTransformer from sklearn.cluster import AgglomerativeClustering # 範例實體列表（待聚類的 ARG 論元短語） entities = [\"United States\", \"USA\", \"U.S.\", \"every Asian person\", \"Asian people\"] # 1. 實體語義向量化 embedder = SentenceTransformer('all-MiniLM-L6-v2') embeddings = embedder.encode(entities) # 2. 語義聚類（凝聚層次聚類） clustering = AgglomerativeClustering(n_clusters=None, distance_threshold=0.4, affinity='cosine', linkage='average') labels = clustering.fit_predict(embeddings) # 輸出每個實體的所屬聚類標籤 for entity, label in zip(entities, labels): print(f\"{entity} -\u003e Cluster {label}\") # 預期輸出: # United States -\u003e Cluster 0 # USA -\u003e Cluster 0 # U.S. -\u003e Cluster 0 # every Asian person -\u003e Cluster 5 # Asian people -\u003e Cluster 5 上述兩步驟將大量冗餘的事件碎片進行了 語義壓縮 。動詞的多樣表達被壓縮到有限的框架，實體的別名被合併為單一節點。如此處理後，我們得到了較為 精簡且規範化 的 敘事事件集 。\n第四部分：網絡構建與可視分析 經過動詞和實體的聚合標準化後，我們得到了較為「乾淨」的事件列表。接下來需要將這些事件組織為 敘事網絡 結構，以便進一步的定量分析與視覺化。\n1. 敘事網絡的定義 敘事網絡本質上是一個 有向帶權圖（directed weighted graph）。\n節點（Nodes） ：代表敘事中的 行動者 （Actor）或 受事者 （Actant）。通常來說，就是論元聚合後得到的實體類別。 邊（Edges） ：節點之間的有向連線表示一種 敘事關係 ，通常對應一個謂詞框架。邊從 ARG0 指向 ARG1，並帶有動詞標籤。 權重（Weights） ：每條邊可賦予一個權重，表示該關係的重要性或強度。最簡單的權重是出現頻次，更嚴謹的方法則可採用 對數機率比（Log-Odds Ratio） 等統計度量，以衡量某事件相對於基線的顯著性。 2. 骨幹提取與降噪 現實語料庫所構建的初始網絡通常非常龐大且複雜。為了突出主要的敘事脈絡，我們需要提取網絡的 多尺度骨幹（Multiscale Backbone）。該算法基於統計顯著性，從加權網絡中篩選出具有顯著連接強度的邊，大幅削減弱聯繫邊數量，使網絡結構更清晰。\nimport networkx as nx # 構建有向加權圖 G = nx.DiGraph() # 假設 aggregated_triplets 是處理好的三元組列表 for (subj, verb, obj) in aggregated_triplets: if G.has_edge(subj, obj): G[subj][obj]['weight'] += 1 else: G.add_edge(subj, obj, label=verb, weight=1) # 骨幹提取：僅保留權重超過平均值的邊（簡化示例） avg_weight = sum([d['weight'] for _,_,d in G.edges(data=True)]) / G.number_of_edges() backbone_edges = [(u,v,d) for u,v,d in G.edges(data=True) if d['weight'] \u003e= avg_weight] G_core = nx.DiGraph() G_core.add_edges_from(backbone_edges) print(\"原始邊數：\", G.number_of_edges()) print(\"骨幹邊數：\", G_core.number_of_edges()) 3. 網絡視覺化與交互分析 交互式圖譜 ：使用如 PyVis、D3.js 等庫生成可交互的網絡圖，允許使用者縮放、懸停節點查看細節。 物理引擎佈局 ：將節點視為帶電粒子，使得連接緊密的節點自動聚攏。這種佈局往往能突出網絡中的 社群結構 （clusters），例如將同一敘事陣營的角色聚集在圖中的相近位置。 樣式編碼 ：利用節點大小、顏色編碼節點的度中心性或類別；使用邊的顏色區分不同類型的動詞（如支持為藍，衝突為紅）。 第五部分：實證應用與發現 基於上述方法構建的敘事網絡，已在多項研究中展示出強大的分析能力。Zhao 等人將這一框架應用於 2017 年法國大選 和 COVID-19 推特語料，有以下關鍵發現：\n角色形象與敘事分化 ：在法國大選推文網絡中，勒龐節點周圍聚集了大量帶有負面意涵的動作（如「攻擊」「指責」）；相對而言，馬克宏節點主要連接著中性或與競選活動相關的動作。兩者對比凸顯出輿論如何透過不同的動詞框架來塑造候選人形象。 事件驅動的敘事變遷 ：透過對不同比時間窗的敘事網絡進行觀察，研究者發現 敘事轉折點 往往與現實中的重大事件高度吻合。例如，在大選期間的一次電視辯論或醜聞曝光之後，網絡中關鍵三元組的出現頻率和結構發生突變。 網絡結構特徵 ：敘事網絡的拓撲結構揭示了輿論場的 核心-邊緣 分佈。一小部分高中心性節點（如國家元首、流行議題）構成了網絡的「核心」，而次要角色或具體事件則處於「邊緣」。 第六部分：前沿方向與挑戰展望 敘事網絡分析作為一種新興範式，仍有廣闊的拓展空間：\n1. 跨模態敘事解析 人類的敘事不僅存在於文字中。\n視覺語義角色標注（Visual SRL） ：目標是讓模型從圖像中產生一個簡潔的事件描述，識別「誰（ARG0）用什麼工具（Instrument）對誰（ARG1）做了什麼（Predicate）」。 視頻事件敘事（Video SRL） ：將一段影片劃分為若干時間片段，識別並串聯多個連續事件，形成跨模態的敘事圖譜。 2. 技術局限與研發挑戰 隱喻與反諷理解 ：網絡輿論中充斥著反諷，目前的 SRL 模型主要針對顯性語義，可能錯將諷刺當支持。 跨句敘事鏈抽取 ：現有方法多在單句範圍內抽取事件，如何將分散在多句中的線索串聯起來是下一步需要解決的問題。 大模型與生成式方法 ：利用 LLM 強大的上下文理解能力，直接閱讀完整文檔後 生成 一個結構化的敘事圖譜，可能是未來的方向。 結語 ：敘事網絡分析作為文本挖掘領域的新興方法，正引領我們從關注詞彙頻率轉向關注行動邏輯。借助 SRL 等技術，我們得以自動擷取大規模文本中的「誰-做了什麼-給了誰」，進而構建出可量化、可視化的敘事全貌。\n參考資料 SOURCE: IC2S2 OSoMe Tutorial 2024 AUTHOR: @湯圓鍵盤壞了不能寫論文 [1] Zhao, W. et al. (2024). Discovering Collective Narratives Shifts in Online Discussions. ICWSM 2024. [2] Willaert, T. et al. (2023). Extracting narrative signals from public discourse: a network-based approach. Humanit. Soc. Sci. Commun. [3] Serrano, M. Á. et al. (2009). Extracting the multiscale backbone of complex weighted networks. PNAS. [4] Reimers, N., Gurevych, I. (2019). Sentence-BERT: Sentence Embeddings using Siamese BERT-Networks. EMNLP 2019. [5] Yatskar, M. et al. (2016). Situation Recognition: Visual Semantic Role Labeling for Image Understanding. CVPR 2016. [6] OSoMe Tutorial 2024 / IC2S2 Tutorial on Narrative Networks. ",
  "wordCount" : "578",
  "inLanguage": "en",
  "datePublished": "2026-01-04T00:00:00Z",
  "dateModified": "2026-01-04T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Lyuxi Liu"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://llspublic.github.io/posts/srl/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Lyuxi Liu",
    "logo": {
      "@type": "ImageObject",
      "url": "https://llspublic.github.io/favicon.ico"
    }
  }
}
</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://llspublic.github.io/" accesskey="h" title="Lyuxi Liu (Alt + H)">Lyuxi Liu</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                    <ul class="lang-switch"><li>|</li>
                        <li>
                            <a href="https://llspublic.github.io/zh/" title="中文"
                                aria-label="中文">Zh</a>
                        </li>
                    </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://llspublic.github.io/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://llspublic.github.io/archive/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      深入研究敘事網絡：從「詞頻統計」到「結構化行動邏輯」
    </h1>
    <div class="post-meta"><span title='2026-01-04 00:00:00 +0000 UTC'>January 4, 2026</span>&nbsp;·&nbsp;<span>Lyuxi Liu</span>

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e7%82%ba%e4%bb%80%e9%ba%bc%e6%88%91%e5%80%91%e9%9c%80%e8%a6%81%e6%95%98%e4%ba%8b%e7%b6%b2%e7%b5%a1" aria-label="為什麼我們需要敘事網絡？">為什麼我們需要敘事網絡？</a><ul>
                        
                <li>
                    <a href="#%e7%af%84%e5%bc%8f%e5%b0%8d%e6%af%94%e5%85%b1%e8%a9%9e%e7%b6%b2%e7%b5%a1-vs-%e6%95%98%e4%ba%8b%e7%b6%b2%e7%b5%a1" aria-label="範式對比：共詞網絡 vs. 敘事網絡">範式對比：共詞網絡 vs. 敘事網絡</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%ac%ac%e4%b8%80%e9%83%a8%e5%88%86%e7%90%86%e8%ab%96%e8%a6%96%e8%a7%92%e5%be%9e%e8%a9%b1%e9%a1%8c%e6%8c%96%e6%8e%98%e5%88%b0%e6%95%98%e4%ba%8b%e8%a7%a3%e6%9e%90" aria-label="第一部分：理論視角——從話題挖掘到敘事解析">第一部分：理論視角——從話題挖掘到敘事解析</a></li>
                <li>
                    <a href="#%e7%ac%ac%e4%ba%8c%e9%83%a8%e5%88%86%e6%a0%b8%e5%bf%83%e6%8a%80%e8%a1%93%e8%aa%9e%e7%be%a9%e8%a7%92%e8%89%b2%e6%a8%99%e6%b3%a8-srl" aria-label="第二部分：核心技術——語義角色標注 (SRL)">第二部分：核心技術——語義角色標注 (SRL)</a><ul>
                        
                <li>
                    <a href="#propbank-%e6%a8%99%e8%a8%bb%e9%ab%94%e7%b3%bb%e7%a4%ba%e4%be%8b" aria-label="PropBank 標註體系示例">PropBank 標註體系示例</a></li>
                <li>
                    <a href="#srl-%e5%b7%a5%e5%85%b7%e8%88%87%e6%a8%a1%e5%9e%8b" aria-label="SRL 工具與模型">SRL 工具與模型</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%ac%ac%e5%9b%9b%e9%83%a8%e5%88%86%e7%b6%b2%e7%b5%a1%e6%a7%8b%e5%bb%ba%e8%88%87%e5%8f%af%e8%a6%96%e5%88%86%e6%9e%90" aria-label="第四部分：網絡構建與可視分析">第四部分：網絡構建與可視分析</a><ul>
                        
                <li>
                    <a href="#1-%e6%95%98%e4%ba%8b%e7%b6%b2%e7%b5%a1%e7%9a%84%e5%ae%9a%e7%be%a9" aria-label="1. 敘事網絡的定義">1. 敘事網絡的定義</a></li>
                <li>
                    <a href="#2-%e9%aa%a8%e5%b9%b9%e6%8f%90%e5%8f%96%e8%88%87%e9%99%8d%e5%99%aa" aria-label="2. 骨幹提取與降噪">2. 骨幹提取與降噪</a></li>
                <li>
                    <a href="#3-%e7%b6%b2%e7%b5%a1%e8%a6%96%e8%a6%ba%e5%8c%96%e8%88%87%e4%ba%a4%e4%ba%92%e5%88%86%e6%9e%90" aria-label="3. 網絡視覺化與交互分析">3. 網絡視覺化與交互分析</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%ac%ac%e4%ba%94%e9%83%a8%e5%88%86%e5%af%a6%e8%ad%89%e6%87%89%e7%94%a8%e8%88%87%e7%99%bc%e7%8f%be" aria-label="第五部分：實證應用與發現">第五部分：實證應用與發現</a></li>
                <li>
                    <a href="#%e7%ac%ac%e5%85%ad%e9%83%a8%e5%88%86%e5%89%8d%e6%b2%bf%e6%96%b9%e5%90%91%e8%88%87%e6%8c%91%e6%88%b0%e5%b1%95%e6%9c%9b" aria-label="第六部分：前沿方向與挑戰展望">第六部分：前沿方向與挑戰展望</a><ul>
                        
                <li>
                    <a href="#1-%e8%b7%a8%e6%a8%a1%e6%85%8b%e6%95%98%e4%ba%8b%e8%a7%a3%e6%9e%90" aria-label="1. 跨模態敘事解析">1. 跨模態敘事解析</a></li>
                <li>
                    <a href="#2-%e6%8a%80%e8%a1%93%e5%b1%80%e9%99%90%e8%88%87%e7%a0%94%e7%99%bc%e6%8c%91%e6%88%b0" aria-label="2. 技術局限與研發挑戰">2. 技術局限與研發挑戰</a></li>
                <li>
                    <a href="#%e5%8f%83%e8%80%83%e8%b3%87%e6%96%99" aria-label="參考資料">參考資料</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><blockquote>
<p><strong>導言</strong>：在社會科學研究中，面對海量文本數據，我們常使用詞雲（Word Cloud）或主題模型（LDA）來提取熱點話題。然而，這些方法僅告訴我們人們在「討論什麼」（What），卻難以揭示「誰對誰做了什麼」（Who did what to whom）這一社會互動的核心邏輯。</p>
</blockquote>
<p>敘事不僅僅是高頻詞的線性排列，更是通過事件將行動者與受體連接起來、建構社會現實的過程。本文將介紹一種新的分析範式——<strong>敘事網絡（Narrative Network）</strong>，並詳細拆解其背後的技術實現路徑。</p>
<h2 id="為什麼我們需要敘事網絡">為什麼我們需要敘事網絡？<a hidden class="anchor" aria-hidden="true" href="#為什麼我們需要敘事網絡">#</a></h2>
<p>傳統的詞袋模型將文本表示為無序詞彙的集合，使我們無法重構句子中角色與行動間的確切關係。詞頻或主題分佈固然能提供語料概覽，但 <strong>「關鍵詞/主題 ≠ 完整敘事」</strong>。例如，LDA 主題模型會將文本歸納為若干主題，但這些主題僅僅是詞的概率分佈，缺乏對敘事結構（如因果、角色互動）的顯式描述。</p>
<p><strong>敘事網絡（Narrative Network）</strong> 提供了一種新的分析範式：將文本視為 <strong>事件序列</strong> 而非靜態詞集，強調行動者、行動和受事者之間的 <strong>結構化互動</strong>。換言之，敘事網絡關注 <strong>「誰」（施事者）</strong> 、 <strong>「對誰」（受事者）</strong> 、 <strong>「做了什麼」（動作）</strong>，從而捕捉文本中的因果脈絡和責任歸屬。這讓這種範式轉變讓我們得以超越話題探討層面，深入研究語篇如何塑造社會認知與權力結構。</p>
<h3 id="範式對比共詞網絡-vs-敘事網絡">範式對比：共詞網絡 vs. 敘事網絡<a hidden class="anchor" aria-hidden="true" href="#範式對比共詞網絡-vs-敘事網絡">#</a></h3>
<table>
  <thead>
      <tr>
          <th style="text-align: left">分析維度</th>
          <th style="text-align: left">共詞網絡 (Co-word Network)</th>
          <th style="text-align: left">敘事網絡 (Narrative Network)</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left"><strong>基本單元</strong></td>
          <td style="text-align: left">詞彙 A – 詞彙 B（共現關係）</td>
          <td style="text-align: left">施事者 – 動作 – 受事者（事件三元組）</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>連接依據</strong></td>
          <td style="text-align: left">統計關聯（詞頻/共現）</td>
          <td style="text-align: left">語義互動（角色關係）</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>網絡類型</strong></td>
          <td style="text-align: left">無向圖（Undirected）</td>
          <td style="text-align: left">有向圖（Directed）</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>可解釋性</strong></td>
          <td style="text-align: left">話題相關度（討論內容）</td>
          <td style="text-align: left">行動邏輯（誰對誰做了什麼）</td>
      </tr>
  </tbody>
</table>
<p>敘事網絡通過保留事件結構，大幅增強了對社會現實構建過程的解釋力。例如，Sudhahar 等人使用新聞報導的主謂賓關係構建網絡，發現美國大選語料中自發形成了支持與反對的兩大陣營。總體而言，相較於傳統詞彙共現分析，敘事網絡能更好地揭示文本背後的權力關係和因果鏈條，是政治傳播、輿情分析等領域強有力的工具。</p>
<hr>
<h2 id="第一部分理論視角從話題挖掘到敘事解析">第一部分：理論視角——從話題挖掘到敘事解析<a hidden class="anchor" aria-hidden="true" href="#第一部分理論視角從話題挖掘到敘事解析">#</a></h2>
<p>文本分析正經歷從「識別顯性話題」向「解析隱含敘事」的範式轉變。傳統方法著重於 <strong>顯性內容</strong> （如高頻詞、主題），而敘事解析則關注 <strong>隱含結構</strong> （如角色互動、事件邏輯）。這種轉變背後有幾點理論動因：</p>
<ol>
<li><strong>人類是「講故事的動物」</strong> ：敘事被視為人類理解和組織現實的基本方式。線上的敘事動態（如話題涌現、競爭、消亡）會對現實社會產生深遠影響。因此，理解網絡輿論中的敘事結構有助於解讀輿情走向與輿論影響。</li>
<li><strong>克服詞袋模型的局限</strong> ：傳統文本表示忽略了語序與句法，導致我們無法區分「狗咬人」與「人咬狗」這樣意義迥異的敘事。相反，敘事分析強調謂詞及其論元角色，精確捕捉「誰做了什麼」的關係。</li>
<li><strong>解釋社會互動</strong> ：敘事網絡將文本轉化為角色-事件圖譜，使研究者得以從全局角度審視互動模式。例如，可透過網絡中心度辨識輿論場中的核心行動者，或通過子群發現特定議題的敘事共同體。</li>
</ol>
<p>Robert Allen 等人形象地指出，將劇情的時間流程轉化為「二維網絡圖」，可使結構一目了然。總之，應用網絡方法於敘事分析，能讓我們在宏觀上捕捉文本敘事的 <strong>對稱性</strong> 與 <strong>結構特徵</strong>，並量化分析角色間的權力互動。</p>
<hr>
<h2 id="第二部分核心技術語義角色標注-srl">第二部分：核心技術——語義角色標注 (SRL)<a hidden class="anchor" aria-hidden="true" href="#第二部分核心技術語義角色標注-srl">#</a></h2>
<p><strong>語義角色標注 （Semantic Role Labeling, SRL）</strong> 是構建敘事網絡的基石。SRL 的任務是解析句子中謂詞（通常為動詞）及其相關的參與者（論元）角色，即識別「誰在何時何地對誰做了什麼」。這一過程可以視為自動為句子加註劇本角色表：</p>
<ul>
<li><strong>謂詞（Predicate）</strong> ：通常為句子的主要動詞，表示一個動作或事件。</li>
<li><strong>論元（Arguments）</strong> ：與該動作相關的參與者及要素，每個論元扮演特定的語義角色（Semantic Role）。</li>
</ul>
<h3 id="propbank-標註體系示例">PropBank 標註體系示例<a hidden class="anchor" aria-hidden="true" href="#propbank-標註體系示例">#</a></h3>
<ul>
<li><strong>ARG0</strong> ：施事者（Agent），動作的發起者，對應原型施動者。例如在句子「政府推出了新政策」中， <strong>政府</strong> 是 ARG0。</li>
<li><strong>ARG1</strong> ：受事者（Patient），動作的承受者或作用對象。上述例子中， <strong>新政策</strong> 是 ARG1。</li>
<li><strong>ARGM</strong> ：附加參數（Modifier），包括時間（TMP）、地點（LOC）、方式（MNR）等修飾資訊。</li>
</ul>
<p>透過 SRL，非結構化的自然語言被轉換為結構化的事件描述。例如句子 <em>&ldquo;The CDC confirms the first coronavirus case.&rdquo;</em> 經過 SRL 解析後，可得到如下結構：</p>
<blockquote>
<p><strong>[ARG0: The CDC] [V: confirms] [ARG1: the first coronavirus case]</strong></p>
</blockquote>
<h3 id="srl-工具與模型">SRL 工具與模型<a hidden class="anchor" aria-hidden="true" href="#srl-工具與模型">#</a></h3>
<p>早期的 SRL 系統如 SENNA 就已能自動標注簡單句子的語義角色。近年來，由於預訓練語言模型（如 BERT）的出現，SRL 準確率有了大幅提升。例如 <strong>AllenNLP</strong> 平台提供了開箱即用的 SRL 模型——一個基於 BERT 的語義角色標注器。我們可以利用該模型快速對文本進行語義解析，無需從零開始訓練：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> allennlp.predictors <span style="color:#f92672">import</span> Predictor
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 加載預訓練的 BERT-SRL 模型（本地路徑或 URL）</span>
</span></span><span style="display:flex;"><span>predictor <span style="color:#f92672">=</span> Predictor<span style="color:#f92672">.</span>from_path(<span style="color:#e6db74">&#34;[https://storage.googleapis.com/allennlp-public-models/bert-base-srl-2020.11.19.tar.gz](https://storage.googleapis.com/allennlp-public-models/bert-base-srl-2020.11.19.tar.gz)&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 輸入待解析句子</span>
</span></span><span style="display:flex;"><span>sentence <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;The CDC confirms the first coronavirus case.&#34;</span>
</span></span><span style="display:flex;"><span>result <span style="color:#f92672">=</span> predictor<span style="color:#f92672">.</span>predict(sentence<span style="color:#f92672">=</span>sentence)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 輸出語義角色標注結果</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> verb <span style="color:#f92672">in</span> result[<span style="color:#e6db74">&#39;verbs&#39;</span>]:
</span></span><span style="display:flex;"><span>    print(verb[<span style="color:#e6db74">&#39;description&#39;</span>])
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 預期輸出: [ARG0: The CDC] [V: confirms] [ARG1: the first coronavirus case] .</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">## 第三部分：敘事聚合——從微觀事件到宏觀網絡</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>經 SRL 解析後<span style="color:#960050;background-color:#1e0010">，</span>我們將獲得海量 <span style="color:#f92672">**</span>微觀的敘事碎片<span style="color:#f92672">**</span> <span style="color:#960050;background-color:#1e0010">（</span>事件三元組<span style="color:#960050;background-color:#1e0010">）。</span>但這些原始三元組往往非常稀疏且充斥噪音<span style="color:#960050;background-color:#1e0010">——</span>畢竟自然語言的表達千變萬化<span style="color:#960050;background-color:#1e0010">。</span>為了從中抽取穩健的 <span style="color:#f92672">**</span>集體敘事<span style="color:#f92672">**</span> <span style="color:#960050;background-color:#1e0010">，</span>需要對碎片進行聚合和歸一化處理<span style="color:#960050;background-color:#1e0010">，</span>使 <span style="color:#f92672">**</span>相似的角色<span style="color:#f92672">**</span> 和 <span style="color:#f92672">**</span>同義的動作<span style="color:#f92672">**</span> 歸併為統一的節點或關係<span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">### 1. 動詞標準化（Verb Normalization）</span>
</span></span><span style="display:flex;"><span>將語料中意義相近但表達不同的動詞歸並到統一的語義框架下<span style="color:#960050;background-color:#1e0010">。</span>例如將 <span style="color:#960050;background-color:#1e0010">“</span>支持<span style="color:#960050;background-color:#1e0010">”（</span>support<span style="color:#960050;background-color:#1e0010">）、</span> <span style="color:#960050;background-color:#1e0010">“</span>背書<span style="color:#960050;background-color:#1e0010">”（</span>endorse<span style="color:#960050;background-color:#1e0010">）、</span> <span style="color:#960050;background-color:#1e0010">“</span>力挺<span style="color:#960050;background-color:#1e0010">”（</span>back<span style="color:#960050;background-color:#1e0010">）</span>等動詞都映射為<span style="color:#960050;background-color:#1e0010">「</span>支持類<span style="color:#960050;background-color:#1e0010">」</span>的通用動作<span style="color:#960050;background-color:#1e0010">。</span>為實現這一點<span style="color:#960050;background-color:#1e0010">，</span>可以利用 <span style="color:#f92672">**</span>VerbAtlas<span style="color:#f92672">**</span> 等大型詞彙資源<span style="color:#960050;background-color:#1e0010">。</span>VerbAtlas 手工構建了動詞同義詞與框架的對應關係<span style="color:#960050;background-color:#1e0010">，</span>將 <span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">649</span> 個具體動詞歸納為 <span style="color:#ae81ff">466</span> 個通用謂詞框架<span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">### 2. 論元聚類（Argument Clustering）</span>
</span></span><span style="display:flex;"><span>解決不同表述指代同一實體的問題<span style="color:#960050;background-color:#1e0010">。</span>比如語料中出現的 <span style="color:#960050;background-color:#1e0010">“</span>美利堅合眾國<span style="color:#960050;background-color:#1e0010">”</span> <span style="color:#960050;background-color:#1e0010">、</span> <span style="color:#960050;background-color:#1e0010">“</span>美國<span style="color:#960050;background-color:#1e0010">”</span> <span style="color:#960050;background-color:#1e0010">、</span> <span style="color:#960050;background-color:#1e0010">“</span>USA<span style="color:#960050;background-color:#1e0010">”</span> 顯然是同一實體<span style="color:#960050;background-color:#1e0010">，</span>但計算機視角下它們是不同的字符串<span style="color:#960050;background-color:#1e0010">。</span>我們可以利用 <span style="color:#f92672">**</span>語義嵌入<span style="color:#f92672">+</span>聚類<span style="color:#f92672">**</span> 的方法來自動合併這些別名實體<span style="color:#960050;background-color:#1e0010">。</span>實踐中<span style="color:#960050;background-color:#1e0010">，</span>常使用 <span style="color:#f92672">**</span>Sentence<span style="color:#f92672">-</span>BERT<span style="color:#f92672">**</span> 將每個論元短語向量化<span style="color:#960050;background-color:#1e0010">，</span>再採用 <span style="color:#f92672">**</span>凝聚層次聚類<span style="color:#f92672">**</span> <span style="color:#960050;background-color:#1e0010">（</span>Hierarchical Clustering<span style="color:#960050;background-color:#1e0010">）</span>根據語義距離將相似實體歸為一類<span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">```</span>python
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> sentence_transformers <span style="color:#f92672">import</span> SentenceTransformer
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> sklearn.cluster <span style="color:#f92672">import</span> AgglomerativeClustering
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 範例實體列表（待聚類的 ARG 論元短語）</span>
</span></span><span style="display:flex;"><span>entities <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;United States&#34;</span>, <span style="color:#e6db74">&#34;USA&#34;</span>, <span style="color:#e6db74">&#34;U.S.&#34;</span>, <span style="color:#e6db74">&#34;every Asian person&#34;</span>, <span style="color:#e6db74">&#34;Asian people&#34;</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 1. 實體語義向量化</span>
</span></span><span style="display:flex;"><span>embedder <span style="color:#f92672">=</span> SentenceTransformer(<span style="color:#e6db74">&#39;all-MiniLM-L6-v2&#39;</span>)
</span></span><span style="display:flex;"><span>embeddings <span style="color:#f92672">=</span> embedder<span style="color:#f92672">.</span>encode(entities)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 2. 語義聚類（凝聚層次聚類）</span>
</span></span><span style="display:flex;"><span>clustering <span style="color:#f92672">=</span> AgglomerativeClustering(n_clusters<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>, distance_threshold<span style="color:#f92672">=</span><span style="color:#ae81ff">0.4</span>, affinity<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;cosine&#39;</span>, linkage<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;average&#39;</span>)
</span></span><span style="display:flex;"><span>labels <span style="color:#f92672">=</span> clustering<span style="color:#f92672">.</span>fit_predict(embeddings)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 輸出每個實體的所屬聚類標籤</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> entity, label <span style="color:#f92672">in</span> zip(entities, labels):
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>entity<span style="color:#e6db74">}</span><span style="color:#e6db74"> -&gt; Cluster </span><span style="color:#e6db74">{</span>label<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 預期輸出:</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># United States  -&gt; Cluster 0</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># USA            -&gt; Cluster 0</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># U.S.           -&gt; Cluster 0</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># every Asian person -&gt; Cluster 5</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Asian people   -&gt; Cluster 5</span>
</span></span></code></pre></div><p>上述兩步驟將大量冗餘的事件碎片進行了 <strong>語義壓縮</strong> 。動詞的多樣表達被壓縮到有限的框架，實體的別名被合併為單一節點。如此處理後，我們得到了較為 <strong>精簡且規範化</strong> 的 <strong>敘事事件集</strong> 。</p>
<hr>
<h2 id="第四部分網絡構建與可視分析">第四部分：網絡構建與可視分析<a hidden class="anchor" aria-hidden="true" href="#第四部分網絡構建與可視分析">#</a></h2>
<p>經過動詞和實體的聚合標準化後，我們得到了較為「乾淨」的事件列表。接下來需要將這些事件組織為 <strong>敘事網絡</strong> 結構，以便進一步的定量分析與視覺化。</p>
<h3 id="1-敘事網絡的定義">1. 敘事網絡的定義<a hidden class="anchor" aria-hidden="true" href="#1-敘事網絡的定義">#</a></h3>
<p>敘事網絡本質上是一個 <strong>有向帶權圖（directed weighted graph）</strong>。</p>
<ul>
<li><strong>節點（Nodes）</strong> ：代表敘事中的 <strong>行動者</strong> （Actor）或 <strong>受事者</strong> （Actant）。通常來說，就是論元聚合後得到的實體類別。</li>
<li><strong>邊（Edges）</strong> ：節點之間的有向連線表示一種 <strong>敘事關係</strong> ，通常對應一個謂詞框架。邊從 ARG0 指向 ARG1，並帶有動詞標籤。</li>
<li><strong>權重（Weights）</strong> ：每條邊可賦予一個權重，表示該關係的重要性或強度。最簡單的權重是出現頻次，更嚴謹的方法則可採用 <strong>對數機率比（Log-Odds Ratio）</strong> 等統計度量，以衡量某事件相對於基線的顯著性。</li>
</ul>
<h3 id="2-骨幹提取與降噪">2. 骨幹提取與降噪<a hidden class="anchor" aria-hidden="true" href="#2-骨幹提取與降噪">#</a></h3>
<p>現實語料庫所構建的初始網絡通常非常龐大且複雜。為了突出主要的敘事脈絡，我們需要提取網絡的 <strong>多尺度骨幹（Multiscale Backbone）</strong>。該算法基於統計顯著性，從加權網絡中篩選出具有顯著連接強度的邊，大幅削減弱聯繫邊數量，使網絡結構更清晰。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> networkx <span style="color:#66d9ef">as</span> nx
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 構建有向加權圖</span>
</span></span><span style="display:flex;"><span>G <span style="color:#f92672">=</span> nx<span style="color:#f92672">.</span>DiGraph()
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 假設 aggregated_triplets 是處理好的三元組列表</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (subj, verb, obj) <span style="color:#f92672">in</span> aggregated_triplets:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> G<span style="color:#f92672">.</span>has_edge(subj, obj):
</span></span><span style="display:flex;"><span>        G[subj][obj][<span style="color:#e6db74">&#39;weight&#39;</span>] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        G<span style="color:#f92672">.</span>add_edge(subj, obj, label<span style="color:#f92672">=</span>verb, weight<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 骨幹提取：僅保留權重超過平均值的邊（簡化示例）</span>
</span></span><span style="display:flex;"><span>avg_weight <span style="color:#f92672">=</span> sum([d[<span style="color:#e6db74">&#39;weight&#39;</span>] <span style="color:#66d9ef">for</span> _,_,d <span style="color:#f92672">in</span> G<span style="color:#f92672">.</span>edges(data<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)]) <span style="color:#f92672">/</span> G<span style="color:#f92672">.</span>number_of_edges()
</span></span><span style="display:flex;"><span>backbone_edges <span style="color:#f92672">=</span> [(u,v,d) <span style="color:#66d9ef">for</span> u,v,d <span style="color:#f92672">in</span> G<span style="color:#f92672">.</span>edges(data<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>) <span style="color:#66d9ef">if</span> d[<span style="color:#e6db74">&#39;weight&#39;</span>] <span style="color:#f92672">&gt;=</span> avg_weight]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>G_core <span style="color:#f92672">=</span> nx<span style="color:#f92672">.</span>DiGraph()
</span></span><span style="display:flex;"><span>G_core<span style="color:#f92672">.</span>add_edges_from(backbone_edges)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;原始邊數：&#34;</span>, G<span style="color:#f92672">.</span>number_of_edges())
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;骨幹邊數：&#34;</span>, G_core<span style="color:#f92672">.</span>number_of_edges())
</span></span></code></pre></div><h3 id="3-網絡視覺化與交互分析">3. 網絡視覺化與交互分析<a hidden class="anchor" aria-hidden="true" href="#3-網絡視覺化與交互分析">#</a></h3>
<ul>
<li><strong>交互式圖譜</strong> ：使用如 PyVis、D3.js 等庫生成可交互的網絡圖，允許使用者縮放、懸停節點查看細節。</li>
<li><strong>物理引擎佈局</strong> ：將節點視為帶電粒子，使得連接緊密的節點自動聚攏。這種佈局往往能突出網絡中的 <strong>社群結構</strong> （clusters），例如將同一敘事陣營的角色聚集在圖中的相近位置。</li>
<li><strong>樣式編碼</strong> ：利用節點大小、顏色編碼節點的度中心性或類別；使用邊的顏色區分不同類型的動詞（如支持為藍，衝突為紅）。</li>
</ul>
<hr>
<h2 id="第五部分實證應用與發現">第五部分：實證應用與發現<a hidden class="anchor" aria-hidden="true" href="#第五部分實證應用與發現">#</a></h2>
<p>基於上述方法構建的敘事網絡，已在多項研究中展示出強大的分析能力。Zhao 等人將這一框架應用於 <strong>2017 年法國大選</strong> 和 <strong>COVID-19 推特語料</strong>，有以下關鍵發現：</p>
<ol>
<li><strong>角色形象與敘事分化</strong> ：在法國大選推文網絡中，勒龐節點周圍聚集了大量帶有負面意涵的動作（如「攻擊」「指責」）；相對而言，馬克宏節點主要連接著中性或與競選活動相關的動作。兩者對比凸顯出輿論如何透過不同的動詞框架來塑造候選人形象。</li>
<li><strong>事件驅動的敘事變遷</strong> ：透過對不同比時間窗的敘事網絡進行觀察，研究者發現 <strong>敘事轉折點</strong> 往往與現實中的重大事件高度吻合。例如，在大選期間的一次電視辯論或醜聞曝光之後，網絡中關鍵三元組的出現頻率和結構發生突變。</li>
<li><strong>網絡結構特徵</strong> ：敘事網絡的拓撲結構揭示了輿論場的 <strong>核心-邊緣</strong> 分佈。一小部分高中心性節點（如國家元首、流行議題）構成了網絡的「核心」，而次要角色或具體事件則處於「邊緣」。</li>
</ol>
<hr>
<h2 id="第六部分前沿方向與挑戰展望">第六部分：前沿方向與挑戰展望<a hidden class="anchor" aria-hidden="true" href="#第六部分前沿方向與挑戰展望">#</a></h2>
<p>敘事網絡分析作為一種新興範式，仍有廣闊的拓展空間：</p>
<h3 id="1-跨模態敘事解析">1. 跨模態敘事解析<a hidden class="anchor" aria-hidden="true" href="#1-跨模態敘事解析">#</a></h3>
<p>人類的敘事不僅存在於文字中。</p>
<ul>
<li><strong>視覺語義角色標注（Visual SRL）</strong> ：目標是讓模型從圖像中產生一個簡潔的事件描述，識別「誰（ARG0）用什麼工具（Instrument）對誰（ARG1）做了什麼（Predicate）」。</li>
<li><strong>視頻事件敘事（Video SRL）</strong> ：將一段影片劃分為若干時間片段，識別並串聯多個連續事件，形成跨模態的敘事圖譜。</li>
</ul>
<h3 id="2-技術局限與研發挑戰">2. 技術局限與研發挑戰<a hidden class="anchor" aria-hidden="true" href="#2-技術局限與研發挑戰">#</a></h3>
<ul>
<li><strong>隱喻與反諷理解</strong> ：網絡輿論中充斥著反諷，目前的 SRL 模型主要針對顯性語義，可能錯將諷刺當支持。</li>
<li><strong>跨句敘事鏈抽取</strong> ：現有方法多在單句範圍內抽取事件，如何將分散在多句中的線索串聯起來是下一步需要解決的問題。</li>
<li><strong>大模型與生成式方法</strong> ：利用 LLM 強大的上下文理解能力，直接閱讀完整文檔後 <strong>生成</strong> 一個結構化的敘事圖譜，可能是未來的方向。</li>
</ul>
<hr>
<p><strong>結語</strong> ：敘事網絡分析作為文本挖掘領域的新興方法，正引領我們從關注詞彙頻率轉向關注行動邏輯。借助 SRL 等技術，我們得以自動擷取大規模文本中的「誰-做了什麼-給了誰」，進而構建出可量化、可視化的敘事全貌。</p>
<h3 id="參考資料">參考資料<a hidden class="anchor" aria-hidden="true" href="#參考資料">#</a></h3>
<ul>
<li>SOURCE: IC2S2 OSoMe Tutorial 2024</li>
<li>AUTHOR: @湯圓鍵盤壞了不能寫論文</li>
<li>[1] Zhao, W. et al. (2024). <em>Discovering Collective Narratives Shifts in Online Discussions</em>. ICWSM 2024.</li>
<li>[2] Willaert, T. et al. (2023). <em>Extracting narrative signals from public discourse: a network-based approach</em>. Humanit. Soc. Sci. Commun.</li>
<li>[3] Serrano, M. Á. et al. (2009). <em>Extracting the multiscale backbone of complex weighted networks</em>. PNAS.</li>
<li>[4] Reimers, N., Gurevych, I. (2019). <em>Sentence-BERT: Sentence Embeddings using Siamese BERT-Networks</em>. EMNLP 2019.</li>
<li>[5] Yatskar, M. et al. (2016). <em>Situation Recognition: Visual Semantic Role Labeling for Image Understanding</em>. CVPR 2016.</li>
<li>[6] OSoMe Tutorial 2024 / IC2S2 Tutorial on Narrative Networks.</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://llspublic.github.io/tags/digital-humanities/">Digital Humanities</a></li>
      <li><a href="https://llspublic.github.io/tags/computational-social-science/">Computational Social Science</a></li>
      <li><a href="https://llspublic.github.io/tags/nlp/">NLP</a></li>
      <li><a href="https://llspublic.github.io/tags/narrative-networks/">Narrative Networks</a></li>
      <li><a href="https://llspublic.github.io/tags/python/">Python</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="https://llspublic.github.io/">Lyuxi Liu</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
